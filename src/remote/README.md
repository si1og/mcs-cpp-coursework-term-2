# Реализация игры по сети

## Интерфейс высокого уровня

Для игры по сети были реализованы клиент и сервер для игры через TCP/IP или
Unix-сокеты.

Клиент определен классом `ttt::remote::Client` в заголовочном файле 
`remote/client.hpp`. Примерное использование клиента следующее:

```cpp
#include "remote/client.hpp"

ttt::game::IPlayer *make_player(); // get your player

int main() {
  auto player = make_player();
  ttt::remote::ClientCtx ctx;
  auto client = ctx.connect_player("tcp://localhost:5555", player);
  if (client.is_connected()) {
    client.handle_all_updates();
  }
  else {
    // report errors
  }
  delete player;
  return 0;
}
```

Более продвинутое использование клиента приведено в файле `cli_client.cpp`.

Простой сервер реализован классом `ttt::remote::BasicServer`, который определен
в заголовочном файле `remote/server.hpp`. Этот сервер принимает игроков и 
выдает список этих игроков, а так же может провести игру между двумя игроками.

Использование этого сервера в интерактивном режиме не тривиально, поскольку 
требует нескольких потоков для отслеживания подключения новых игроков 
и отслеживания состояния подключенных игроков. Эта функциональность реализована
в файле `cli_server.cpp`.

На основе этих файлов собираются две проргаммы, которые можно запустить как
клиент и как сервер. Для сборки клиента необходимо подключение библиотеки, 
где определены игрок и наблюдатель.

## Протокол взаимодействия клиента и сервера

Клиент и сервер обмениваются сообщениями, формат которых определен в файле
`dto.proto` в терминах библиотеки Protobuf.

Общая схема заключается в том, что клиент подключается к серверу, у них
происходит рукопожатие, в случае успеха которого клиент ожидает от сервера
*обновления*. Когда сервер отправляет обновление, клиент на них отвечает
и снова ожидает обновление.

Рукопожатие начинает клиент с сообщения `JoinRequest`, так указывается тип 
подключения (наблюдатель / игрок), если подключается игрок, он обязан указать
имя; также можно указать пароль сервера.

На это сообщение отвечает сервер сообщением `JoinResponse`, в котором будет
сообщено либо о том, что игрок принят (сообщение `JoinAccepted`), либо о том,
что игроку отказано в соединении (сообщение `JoinRejected`). В сообщении
`JoinAccepted` будут указаны настройки сервера и, возможно, уникальный токен 
игрока на этом сервере. В сообщении `JoinRejected` содержится код причины
отказа.

После сообщения `JoinAccepted` клиент должен отправить сообщение
`ClientResponse` с сообщением о готовности принять обновление. С этого момента
клиент переходит в состояние ожидания обновлений от сервера.  На каждое
обновление клиент отвечает сообщением `ClientResponse`. Следующее сообщение  от
сервера приходит через неопределенное время, однако, обычно сервер довольно
часто проверяет доступность клиента при помощи пинг-обновления.

Сервер отправляет клиенту обновления в виде сообщения `Update`. Оно может 
содержать следующие обновления:

- игровое событие `Event`;
- запрос на ход игрока, на это обновление игрок обязан ответить координатами 
  точки хода в сообщении `ClientResponse`;
- начало новой игры `NewGameUpdate`, в этом сообщении передаются настройки 
  игры;
- пинг-обновление, отправляется для проверки доступности;
- сообщение о выключении сервера.

На каждое обновление игрок обязан ответить сообщением `ClientResponse` и ждать 
следующего обновления.
